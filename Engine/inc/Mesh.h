//////////////////////////////////////////////////////////////////////
//
//  Mesh.h
//  This source file is part of Gre
//		(Gang's Resource Engine)
//
//  Copyright (c) 2015 - 2016 Luk2010
//  Created on 26/11/2015.
//
//////////////////////////////////////////////////////////////////////
/*
 -----------------------------------------------------------------------------
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 -----------------------------------------------------------------------------
 */

#ifndef GRE_Mesh_h
#define GRE_Mesh_h

#include "Resource.h"
#include "BoundingBox.h"

#include "SoftwareVertexBuffer.h"
#include "SoftwareIndexBuffer.h"

GreBeginNamespace

//////////////////////////////////////////////////////////////////////
/// @brief Defines a Mesh Resource Object.
///
/// The Mesh Object is responsible for its own drawing. You can subclass
/// the Mesh::onUpdateEvent() method or the Mesh::onRenderEvent() in order
/// to customize the Mesh.
///
/// Data is stored in the Mesh object as the following.
/// When loading a Mesh from the MeshLoader, your Mesh object will only
/// fills the SoftwareBuffer properties.
///
/// When the Renderer draw the Mesh, if the property Mesh::iUseHardwareBuffers
/// is true, then the Renderer will creates some HardwareBuffer, upload
/// data from the SoftwareBuffer's, and finally will release the SoftwareBuffer's
/// using Mesh::clearSoftwareBuffers().
///
/// This allows the user to separate the loading of the Mesh, which is
/// independent from the Rendering API, to the creation of HardwareBuffer's,
/// which is dependent from the APi.
///
/// You should always use SoftwareVertexBuffers to create a Mesh. The
/// SoftwareVertexBuffer will help making a BoundingBox for the Mesh, if
/// 'iIsBoundingBoxUser' is false. 'set[Vertex/Index]Buffer' assumes that
/// the HardwareBuffers are created using the Renderer from the
/// Software[Vertex/Index]Buffers.
///
/// Modifying the Mesh structure
///
/// If you want to modify the Mesh structure, you may want to modify the
/// Software[Vertex/Index]Buffers and let the Renderer updates the
/// Hardware[Vertex/Index]Buffers directly. If your Mesh doesn't keep
/// Software[Vertex/Index]Buffers, you should update yourself the
/// 'iBoundingBox' property as it rely on Software Buffers.
///
/// Modifying directly the HardwareBuffers using a mapped pointer from the
/// GPU is outdated, the reason is that typically, 'glMapBuffer' is blocking
/// the Gpu driver while you performs your things, so this method is too
/// slow. Updating the whole buffer orphaning it is much faster.
///
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC MeshPrivate : public Resource
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    MeshPrivate(const std::string& name);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~MeshPrivate() noexcept(false);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual const SoftwareVertexBuffer getSoftwareVertexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareVertexBufferHolder reference.
    //////////////////////////////////////////////////////////////////////
    virtual SoftwareVertexBufferHolder& getSoftwareVertexBufferHolder();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the SoftwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareVertexBuffer(const SoftwareVertexBuffer& softvertexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareIndexBuffers.
    //////////////////////////////////////////////////////////////////////
    virtual const SoftwareIndexBuffer getSoftwareIndexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareIndexBufferHolder reference.
    //////////////////////////////////////////////////////////////////////
    virtual SoftwareIndexBufferHolder& getSoftwareIndexBufferHolder();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a SoftwareIndexBuffer to the list.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareIndexBuffer(const SoftwareIndexBuffer& softindexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Vertex Buffer object.
    //////////////////////////////////////////////////////////////////////
    virtual const HardwareVertexBuffer getVertexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the HardwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual void setVertexBuffer(const HardwareVertexBuffer& vertexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Index Buffer batch.
    //////////////////////////////////////////////////////////////////////
    virtual const HardwareIndexBuffer getIndexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds an HardwareIndexBuffer to the list.
    //////////////////////////////////////////////////////////////////////
    virtual void setIndexBuffer(const HardwareIndexBuffer& indexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iUseHardwareBuffers property.
    //////////////////////////////////////////////////////////////////////
    virtual bool useHardwareBuffers() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the iUseHardwareBuffers property.
    //////////////////////////////////////////////////////////////////////
    virtual void setUseHardwareBuffers(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iSoftBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasSoftwareBuffersChanged() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Forces a change to iSoftBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareBuffersChanged(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iHardBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasHardwareBuffersChanged() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Forces a change to iHardBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual void setHardwareBuffersChanged(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Hardware and Software Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clear();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Software Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clearSoftwareBuffers();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Hardware Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clearHardwareBuffers();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iBoundingBox' property.
    //////////////////////////////////////////////////////////////////////
    virtual const BoundingBox& getBoundingBox() const;
    
protected:
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Called when receiving Update Event.
    ///
    /// If 'iSoftVertexBufferUpdate' is true, we updates the HardwareVertexBuffer
    /// from the SoftwareVertexBuffer.
    ///
    /// If 'iSoftIndexBufferUpdate' is true, we updates the HardwareIndexBuffer
    /// from the SoftwareIndexBuffer.
    ///
    /// If 'iSoftVertexBufferUpdate' is true, we updates the 'iBoundingBox' property
    /// if 'iIsBoundingBoxUser' is false, using the SoftwareVertexBuffer.
    ///
    //////////////////////////////////////////////////////////////////////
    virtual void onUpdateEvent(const UpdateEvent& e);
    
private:
    
    /// @brief Holds the SoftwareVertexBuffer.
    SoftwareVertexBufferHolder iSoftVertexBuffer;
    
    /// @brief Holds the SoftwareIndexBuffers.
    SoftwareIndexBufferHolder iSoftIndexBuffer;
    
    /// @brief Holds the HardwareVertexBuffer.
    HardwareVertexBufferHolder iHardVertexBuffer;
    
    /// @brief Holds the HardwareIndexBuffers.
    HardwareIndexBufferHolder iHardIndexBuffer;
    
    /// @brief Mesh's BoundingBox.
    BoundingBox iBoundingBox;
    
    /// @brief True if 'iBoundingBox' has been set by a user.
    /// Setting this property to false will make the Mesh update
    /// the BoundingBox from Software Buffers.
    bool iIsBoundingBoxUser;
    
    /// @brief True if the Renderer can create HardwareBuffers.
    bool iUseHardwareBuffers;
    
    /// @brief True if the Software Buffers have changed.
    mutable bool iSoftBuffersChanged;
    
    /// @brief True if the Hardware Buffers have changed.
    mutable bool iHardBuffersChanged;
    
    /// @brief True if SoftwareVertexBuffer changed.
    mutable bool iSoftVertexBufferUpdate;
    
    /// @brief True if SoftwareIndexBuffer changed.
    mutable bool iSoftIndexBufferUpdate;
};

/// @brief SpecializedResourceHolder for MeshPrivate.
typedef SpecializedResourceHolder<MeshPrivate> MeshHolder;

/// @brief SpecializedResourceHolderList for MeshPrivate.
typedef SpecializedResourceHolderList<MeshPrivate> MeshHolderList;

//////////////////////////////////////////////////////////////////////
/// @brief A proxy to use MeshPrivate.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC Mesh : public SpecializedResourceUser<MeshPrivate>
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    Mesh(const MeshPrivate* pointer);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    Mesh(const MeshHolder& holder);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    Mesh(const Mesh& user);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~Mesh() noexcept(false);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual const SoftwareVertexBuffer getSoftwareVertexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the SoftwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareVertexBuffer(const SoftwareVertexBuffer& softvertexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the SoftwareIndexBuffers.
    //////////////////////////////////////////////////////////////////////
    virtual const SoftwareIndexBuffer getSoftwareIndexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a SoftwareIndexBuffer to the list.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareIndexBuffer(const SoftwareIndexBuffer& softindexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Vertex Buffer object.
    //////////////////////////////////////////////////////////////////////
    virtual const HardwareVertexBuffer getVertexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the HardwareVertexBuffer.
    //////////////////////////////////////////////////////////////////////
    virtual void setVertexBuffer(const HardwareVertexBuffer& vertexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Index Buffer batch.
    //////////////////////////////////////////////////////////////////////
    virtual const HardwareIndexBuffer getIndexBuffer() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds an HardwareIndexBuffer to the list.
    //////////////////////////////////////////////////////////////////////
    virtual void setIndexBuffer(const HardwareIndexBuffer& indexbuffer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iUseHardwareBuffers property.
    //////////////////////////////////////////////////////////////////////
    virtual bool useHardwareBuffers() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the iUseHardwareBuffers property.
    //////////////////////////////////////////////////////////////////////
    virtual void setUseHardwareBuffers(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iSoftBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasSoftwareBuffersChanged() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Forces a change to iSoftBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual void setSoftwareBuffersChanged(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the iHardBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasHardwareBuffersChanged() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Forces a change to iHardBuffersChanged property.
    //////////////////////////////////////////////////////////////////////
    virtual void setHardwareBuffersChanged(bool b);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Hardware and Software Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clear();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Software Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clearSoftwareBuffers();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Hardware Buffers.
    //////////////////////////////////////////////////////////////////////
    virtual void clearHardwareBuffers();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iBoundingBox' property.
    //////////////////////////////////////////////////////////////////////
    virtual const BoundingBox& getBoundingBox() const;
    
    /// @brief Null Mesh Property.
    static Mesh Null;
};

//////////////////////////////////////////////////////////////////////
/// @brief ResourceLoader for Mesh.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC MeshLoader : public ResourceLoader
{
public:
    
    POOLED(Pools::Loader)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    MeshLoader();
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~MeshLoader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Mesh from given file.
    /// This function should always be provided in order to genrically loads
    /// a Mesh from a given file.
    //////////////////////////////////////////////////////////////////////
    virtual MeshHolder load ( const std::string& name , const std::string& filepath ) const = 0;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the file given is loadable by this loader.
    //////////////////////////////////////////////////////////////////////
    virtual bool isLoadable( const std::string& filepath ) const = 0;
};

/// @brief ResourceLoaderFactory for MeshLoader.
typedef ResourceLoaderFactory<MeshLoader> MeshLoaderFactory;

//////////////////////////////////////////////////////////////////////
/// @brief Manages the loaded Mesh's objects.
///
/// Permits the user to easily load Mesh and manages them. Let share
/// the Mesh's from different use.
///
/// You can load a Mesh using MeshManager::load( name , filename ). This
/// function should register the Mesh to the Manager and return a Mesh
/// user object.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC MeshManager
{
public:
    
    POOLED(Pools::Manager)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    MeshManager();
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~MeshManager();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a Rectangle in the same Plane than (x, y) .
    //////////////////////////////////////////////////////////////////////
    Mesh createRectangle ( const Surface& surface );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Mesh to this Manager.
    //////////////////////////////////////////////////////////////////////
    Mesh load ( const MeshHolder& holder );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Mesh using the first compatible ResourceLoader
    /// registered in the Factory.
    /// If a Mesh of the same name already exists, the name will be
    /// appended with a '*'.
    //////////////////////////////////////////////////////////////////////
    Mesh load ( const std::string& name , const std::string& filepath );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if given Mesh has already been loaded.
    //////////////////////////////////////////////////////////////////////
    bool isLoaded ( const std::string& name ) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the given Mesh if it has already been loaded, or
    /// loads it using given filepath and returns it.
    //////////////////////////////////////////////////////////////////////
    Mesh get ( const std::string& name , const std::string& filepath );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the given Mesh if it has already been loaded.
    //////////////////////////////////////////////////////////////////////
    const Mesh get ( const std::string& name ) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Unload given Mesh.
    //////////////////////////////////////////////////////////////////////
    void unload ( const std::string& name );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clear every Mesh's loaded in this Manager.
    //////////////////////////////////////////////////////////////////////
    void clearMeshes();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the MeshLoaderFactory.
    //////////////////////////////////////////////////////////////////////
    MeshLoaderFactory& getLoaderFactory();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the MeshLoaderFactory.
    //////////////////////////////////////////////////////////////////////
    const MeshLoaderFactory& getLoaderFactory() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clear the Manager.
    //////////////////////////////////////////////////////////////////////
    void clear();
    
protected:
    
    /// @brief The MeshLoader's Factory.
    MeshLoaderFactory iLoaders;
    
    /// @brief A set of Mesh loaded by this Manager.
    MeshHolderList iMeshes;
};

GreEndNamespace

#endif
