//////////////////////////////////////////////////////////////////////
//
//  Material.h
//  This source file is part of Gre
//		(Gang's Resource Engine)
//
//  Copyright (c) 2015 - 2017 Luk2010
//  Created on 26/11/2015.
//
//////////////////////////////////////////////////////////////////////
/*
 -----------------------------------------------------------------------------
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 -----------------------------------------------------------------------------
 */

#ifndef GRE_Material_h
#define GRE_Material_h

#include "Color.h"
#include "Texture.h"
#include "HardwareProgram.h"

GreBeginNamespace

enum class FaceType
{
    Front,
    Back,
    FrontAndBack
};

//////////////////////////////////////////////////////////////////////
/// @brief Regroups every data used to draw a Face like the Textures
/// and others data.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC Material : public Resource
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    Material(const std::string& name = "DefaultMaterialManager");
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~Material() noexcept ( false ) ;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Texture object associated to this Material at
    /// index '0'.
    //////////////////////////////////////////////////////////////////////
    virtual void setTexture ( const TextureUser& tex );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Texture object associated to this Material at
    /// given index.
    //////////////////////////////////////////////////////////////////////
    virtual void setTexture ( const TextureUser& tex , size_t index );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Texture at index '0', or Texture::Null if it
    /// doesn't exists.
    //////////////////////////////////////////////////////////////////////
    virtual const TextureUser getTexture() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Texture at given index, or Texture::Null if it
    /// doesn't exists.
    //////////////////////////////////////////////////////////////////////
    virtual const TextureUser getTexture ( size_t index ) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns every Textures in this Material.
    //////////////////////////////////////////////////////////////////////
    virtual const std::vector<TextureUser> & getTextures() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears Texture at index '0'.
    //////////////////////////////////////////////////////////////////////
    virtual void clearTexture();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears Texture at given index.
    //////////////////////////////////////////////////////////////////////
    virtual void clearTexture(size_t index);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears every Texture.
    //////////////////////////////////////////////////////////////////////
    virtual void clearTextures();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if at least one Texture is valid.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasTexture() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if at least two Texture are valid.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasMultitexture() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iAmbient' property.
    //////////////////////////////////////////////////////////////////////
    virtual const Color& getAmbient() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the 'iAmbient' property.
    //////////////////////////////////////////////////////////////////////
    virtual void setAmbient ( const Color& color );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iDiffuse' property.
    //////////////////////////////////////////////////////////////////////
    virtual const Color& getDiffuse() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the 'iDiffuse' property.
    //////////////////////////////////////////////////////////////////////
    virtual void setDiffuse ( const Color& color );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iSpecular' property.
    //////////////////////////////////////////////////////////////////////
    virtual const Color& getSpecular() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the 'iSpecular' property.
    //////////////////////////////////////////////////////////////////////
    virtual void setSpecular ( const Color& color );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iEmission' property.
    //////////////////////////////////////////////////////////////////////
    virtual const Color& getEmission() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the 'iEmission' property.
    //////////////////////////////////////////////////////////////////////
    virtual void setEmission ( const Color& color );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iShininess' property.
    //////////////////////////////////////////////////////////////////////
    virtual float getShininess() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the 'iShininess' property.
    //////////////////////////////////////////////////////////////////////
    virtual void setShininess ( float f );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Configure the HardwareProgram to use this Material.
    //////////////////////////////////////////////////////////////////////
    virtual void configureProgram ( const HardwareProgramHolder & program ) const ;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns 'iNormalMap'
    //////////////////////////////////////////////////////////////////////
    virtual const TextureUser & getNormalMap () const ;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets 'iNormalMap'.
    //////////////////////////////////////////////////////////////////////
    virtual void setNormalMap ( const TextureUser & texture ) ;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns 'iNormalMapEnabled'.
    //////////////////////////////////////////////////////////////////////
    virtual bool isNormalMapEnabled () const ;
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual void setNormalMapEnabled ( bool value ) ;
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual const TextureUser & getSpecularTexture () const ;
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual void setSpecularTexture ( const TextureUser& texture ) ;
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual bool isSpecularTextureEnabled () const ;
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual void setSpecularTextureEnabled ( bool value ) ;
    
private:
    
    /// @brief Emission color.
    Color iEmission;
    
    /// @brief Ambient color.
    Color iAmbient;
    
    /// @brief Diffuse color.
    Color iDiffuse;
    
    /// @brief Specular color.
    Color iSpecular;
    
    /// @brief Shininess.
    float iShininess;
    
    /// @brief Array of Color Textures.
    std::vector<TextureUser> iTextures;
    
    /// @brief A normal map. Check 'iNormalMapEnabled' to see if this normal map
    /// should be used.
    TextureUser iNormalMap ;
    
    /// @brief True if the normal map should be used instead of normals vectors.
    bool iNormalMapEnabled ;
    
    /// @brief A Specular Texture. Check 'iSpecularTextureEnabled' to see if specular texture is used.
    TextureUser iSpecularTexture ;
    
    /// @brief True if the specular components should be the specular texture.
    bool iSpecularTextureEnabled ;
};

/// @brief SpecializedCountedObjectHolder for MaterialPrivate.
typedef SpecializedCountedObjectHolder<Material> MaterialHolder;

/// @brief SpecializedResourceHolderList for MaterialPrivate.
typedef SpecializedResourceHolderList<Material> MaterialHolderList;

/// @brief SpecializedCountedObjectUser.
typedef SpecializedCountedObjectUser<Material> MaterialUser;

/// @brief std::vector for Material.
typedef std::vector<MaterialUser> MaterialVector;

//////////////////////////////////////////////////////////////////////
/// @brief ResourceLoader for MaterialPrivate.
//////////////////////////////////////////////////////////////////////
class MaterialLoader : public ResourceLoader
{
public:
    
    POOLED(Pools::Loader)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    MaterialLoader();
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~MaterialLoader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a file that should contains one or more Materials.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialHolderList load ( const std::string& filepath ) const = 0;
};

/// @brief ResourceLoaderFactory for MaterialLoader.
typedef ResourceLoaderFactory<MaterialLoader> MaterialLoaderFactory;

//////////////////////////////////////////////////////////////////////
/// @brief Material Manager.
//////////////////////////////////////////////////////////////////////
class MaterialManager : public Resource
{
public:
    
    POOLED(Pools::Manager)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    MaterialManager( const std::string & name = "DefaultMaterialManager" );
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~MaterialManager();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a blank default Material ready to be customized.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialHolder create ( const std::string& name ) ;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a File that should contains Materials. If one of the
    /// Material found in the file is already loaded, it will be ignored.
    /// @return Every Material found in this file.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialVector load ( const std::string& filepath );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Material in the Manager.
    /// If this Material already exists, return Material::Null.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialUser load ( const MaterialHolder& material );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a Material with given name, or Material::Null if
    /// not found.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialUser get ( const std::string& name );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a Material with given name, or Material::Null if
    /// not found.
    //////////////////////////////////////////////////////////////////////
    virtual const MaterialUser get ( const std::string& name ) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Remove the Material if it is loaded into this Manager.
    //////////////////////////////////////////////////////////////////////
    virtual void remove ( const std::string& name );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Remove every Materials.
    //////////////////////////////////////////////////////////////////////
    virtual void clearMaterials();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the MaterialLoaderFactory.
    //////////////////////////////////////////////////////////////////////
    virtual MaterialLoaderFactory& getMaterialLoaderFactory();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the MaterialLoaderFactory.
    //////////////////////////////////////////////////////////////////////
    virtual const MaterialLoaderFactory& getMaterialLoaderFactory() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the Materials loaded and the MaterialLoaderFactory.
    //////////////////////////////////////////////////////////////////////
    virtual void clear();
    
protected:
    
    /// @brief Material's loaded list.
    MaterialHolderList iMaterials;
    
    /// @brief MaterialLoaderFactory.
    MaterialLoaderFactory iFactory;
};

/// @brief SpecializedCountedObjectHolder for MaterialManager.
typedef SpecializedCountedObjectHolder < MaterialManager > MaterialManagerHolder ;

GreEndNamespace

#endif
