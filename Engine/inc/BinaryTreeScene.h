//
//  BinaryTreeScene.h
//  GRE
//
//  Created by Jacques Tronconi on 20/12/2015.
//
//
/*
#ifndef GRE_BinaryTreeScene_h
#define GRE_BinaryTreeScene_h

#include "Scene.h"
#include "Node.h"

GreBeginNamespace

class DLL_PUBLIC BinaryTreeNodePrivate : public NodePrivate
{
public:
    
    /// @brief A typed shared pointer to hold the Node.
    typedef std::shared_ptr<BinaryTreeNodePrivate> NodeTyped;
    
    POOLED(Pools::Resource)
    
    BinaryTreeNodePrivate(const std::string& name = std::string());
    ~BinaryTreeNodePrivate();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a new child to this Node.
    /// @param child    The Node to add.
    //////////////////////////////////////////////////////////////////////
    Node addChild(const Node& child);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a new child to this Node.
    /// @param child    The Node to add.
    //////////////////////////////////////////////////////////////////////
    Node addChild(NodePrivate* child);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Mesh used by this Node.
    //////////////////////////////////////////////////////////////////////
    void setMesh(const Mesh& mesh);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Mesh contained in a Node, if this node contains
    /// a mesh or Mesh::Null.
    //////////////////////////////////////////////////////////////////////
    Mesh& getMesh();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Mesh contained in a Node, if this node contains
    /// a mesh or Mesh::Null.
    //////////////////////////////////////////////////////////////////////
    const Mesh& getMesh() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Camera holded by this Node.
    //////////////////////////////////////////////////////////////////////
    void setCamera(const Camera& camera);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Camera holded in this Node, or Camera::Null if
    /// none is holded.
    //////////////////////////////////////////////////////////////////////
    Camera& getCamera();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Camera holded in this Node, or Camera::Null if
    /// none is holded.
    //////////////////////////////////////////////////////////////////////
    const Camera& getCamera() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the parent of given child.
    /// @param child    The node to find the parent.
    /// @param thisNode This node, but in Node version.
    //////////////////////////////////////////////////////////////////////
    Node findParent(const Node& child, Node thisNode);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Parent of this Node.
    //////////////////////////////////////////////////////////////////////
    void setParent(const Node& node);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Node at the righest point.
    //////////////////////////////////////////////////////////////////////
    Node getNodeMostRight() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Parent Node as a BinaryTreeNodePrivate.
    //////////////////////////////////////////////////////////////////////
    const std::weak_ptr<BinaryTreeNodePrivate> getParentTyped() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Left Node as a BinaryTreeNodePrivate.
    //////////////////////////////////////////////////////////////////////
    Node getNodeLeft() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Translate the Node by given vector.
    //////////////////////////////////////////////////////////////////////
    void translate(const Vector3& vector);
    
private:
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Quickly recalculate the tree childs to change translations.
    //////////////////////////////////////////////////////////////////////
    void _calculateTranslation();
    
    Mesh      _mMesh;       ///< @brief Mesh property. Not null if contains one.
    Camera    _mCamera;     ///< @brief Camera propery. Not null if contains one.
    
    Scene     _mScene;      ///< @brief The Scene object which constructed this Node.
    Node      _mNodeParent; ///< @brief The Parent of this Node.
    NodeTyped _mNodeLeft;   ///< @brief Contains the node which, by distance, is between the parent node and this node.
    NodeTyped _mNodeRight;  ///< @brief Contains the node which, by distance, is between this node and the left node of this one.
};

//////////////////////////////////////////////////////////////////////
/// @brief An example Scene that manages the Node's using a Binary
/// Tree.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC BinaryTreeScenePrivate : public ScenePrivate
{
public:
    
    POOLED(Pools::Resource)
    
    BinaryTreeScenePrivate (const std::string& name);
    ~BinaryTreeScenePrivate ();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Root node from the node tree.
    //////////////////////////////////////////////////////////////////////
    Node& getRoot();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Root node from the node tree.
    //////////////////////////////////////////////////////////////////////
    const Node& getRoot() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a new node.
    /// @param mesh     A Mesh to initialize the Node with.
    //////////////////////////////////////////////////////////////////////
    NodePrivate* createNode(const Mesh& mesh);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a new Node with a camera in it.
    //////////////////////////////////////////////////////////////////////
    NodePrivate* createNode(const Camera& camera);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Empty the Scene and destroy every Node objects.
    //////////////////////////////////////////////////////////////////////
    void clear();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the currently active camera.
    //////////////////////////////////////////////////////////////////////
    Camera& getCamera();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the currently active camera.
    //////////////////////////////////////////////////////////////////////
    const Camera& getCamera() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a list of the Nodes, sorted by given filter.
    /// @param filter   A filter defined by the Node to sort them.
    //////////////////////////////////////////////////////////////////////
    std::vector<const Node> getNodesByFilter(Node::Filter filter) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets the active Camera given its Node.
    //////////////////////////////////////////////////////////////////////
    void setActiveCamera(const Node& cameraNode);
    
private:
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Retrieve the parent of given node and returns it.
    //////////////////////////////////////////////////////////////////////
    Node _retrieveNodeParent(const Node& child) const;
    
    Node _mNodeRootWeak;                                   ///< @brief The Root Node, but in Node pointer.
    std::shared_ptr<BinaryTreeNodePrivate> _mNodeRoot;     ///< @brief The Root node.
    std::weak_ptr<BinaryTreeNodePrivate> _mActiveCamera;   ///< @brief The currently active Camera.
};

class DLL_PUBLIC BinaryTreeSceneLoader : public SceneLoader
{
public:
    
    POOLED(Pools::Loader)
    
    BinaryTreeSceneLoader();
    ~BinaryTreeSceneLoader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if Resource::Type is ::Scene.
    //////////////////////////////////////////////////////////////////////
    bool isTypeSupported(Resource::Type type) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a scene.
    /// Default implementation returns a null pointer.
    //////////////////////////////////////////////////////////////////////
    Resource* load(Resource::Type type, const std::string& name) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a clone of this object.
    //////////////////////////////////////////////////////////////////////
    ResourceLoader* clone() const;
};

GreEndNamespace

#endif
*/