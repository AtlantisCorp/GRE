//
//  NodePrivate.h
//  GRE
//
//  Created by Jacques Tronconi on 06/01/2016.
//
//

#ifndef GRE_NodePrivate_h
#define GRE_NodePrivate_h

/*
#include "Pools.h"
#include "Resource.h"
#include "Mesh.h"
#include "Camera.h"

GreBeginNamespace

class DLL_PUBLIC Node;
class DLL_PUBLIC Scene;

//////////////////////////////////////////////////////////////////////
/// @brief A Generic Base Node object.
///
/// Why make a Resource object for a Node ?
///
/// A Node object can be created by any plugin (from the Scene object),
/// and so needs to have an interface with which the user will be able to
/// interact normally.
///
/// The Node implementator should not take care about adding those
/// objects to the ResourceManager. He can just hold an std::vector filled
/// with std::shared_ptr, pointing to NodePrivate object.
/// The Goal here is to make Node an interface fully customizable for the
/// maintainer, but also easilly usable by the user.
///
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC NodePrivate : public Resource
{
public:
    
    POOLED(Pools::Resource)
    
    NodePrivate(const std::string& name = std::string());
    virtual ~NodePrivate();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a new child to this Node.
    /// In the case the Node could not be added, Node::Null is returned by
    /// by the Node user object. This function should return nullptr.
    /// The Node may or may not store the child, depending on the
    /// implementation. Keep in mind that a std::shared_ptr has to manage
    /// the lifetime of the NodePrivate object, because Node is a ResourceUser
    /// so it only has a std::weak_ptr.
    /// @param child    The Node to add.
    //////////////////////////////////////////////////////////////////////
    virtual Node addChild(const Node& child);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a new child to this Node.
    /// This function should take ownership of the shared pointer.
    /// @param child    The Node to add.
    //////////////////////////////////////////////////////////////////////
    virtual Node addChild(NodePrivate* child);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Translate the Node by given vector.
    //////////////////////////////////////////////////////////////////////
    virtual void translate(const Vector3& vector);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Rotates the Node from given Angle to given Axis.
    //////////////////////////////////////////////////////////////////////
    virtual void rotate(float angle, const Vector3& axe);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Set the visible property of the Node.
    /// Normally, if the visible property is set to false, the Node will
    /// not be drew.
    //////////////////////////////////////////////////////////////////////
    virtual void setVisible(bool visible);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the value of the visible property.
    //////////////////////////////////////////////////////////////////////
    virtual bool isVisible() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Mesh used by this Node.
    //////////////////////////////////////////////////////////////////////
    virtual void setMesh(const Mesh& mesh);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Mesh contained in a Node, if this node contains
    /// a mesh or Mesh::Null.
    //////////////////////////////////////////////////////////////////////
    virtual Mesh& getMesh();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Mesh contained in a Node, if this node contains
    /// a mesh or Mesh::Null.
    //////////////////////////////////////////////////////////////////////
    virtual const Mesh& getMesh() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Camera holded by this Node.
    //////////////////////////////////////////////////////////////////////
    virtual void setCamera(const Camera& camera);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Camera holded in this Node, or Camera::Null if
    /// none is holded.
    //////////////////////////////////////////////////////////////////////
    virtual Camera& getCamera();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Camera holded in this Node, or Camera::Null if
    /// none is holded.
    //////////////////////////////////////////////////////////////////////
    virtual const Camera& getCamera() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the Parent of this Node.
    //////////////////////////////////////////////////////////////////////
    virtual void setParent(const Node& node);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets the Scene owning this Node.
    //////////////////////////////////////////////////////////////////////
    virtual void setScene(const Scene& scene);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Gets the Scene owning this Node.
    //////////////////////////////////////////////////////////////////////
    virtual Scene getScene() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Changes the owning of this Node.
    //////////////////////////////////////////////////////////////////////
    void setThisNode(const Node& thisNode);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns this NodePrivate object into a Node object.
    //////////////////////////////////////////////////////////////////////
    Node toNode() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Node matrix.
    //////////////////////////////////////////////////////////////////////
    Matrix4 getNodeMatrix();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Node matrix.
    //////////////////////////////////////////////////////////////////////
    const Matrix4 getNodeMatrix() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets the Node matrix.
    //////////////////////////////////////////////////////////////////////
    void setNodeMatrix(const Matrix4& mat4);
    
protected:
    
    /// @brief Visible property (will be drew or not.)
    bool _mIsVisible;
    
    /// @brief Node matrix. (Position referenced in the Node's view)
    Matrix4 _mMatrix;
    
    /// @brief Holds a Node object to this NodePrivate. This property can seems strange, but it is
    /// useful in some cases, because this weak_ptr must hold an adress to the currently holding
    /// shared_ptr.
    std::weak_ptr<NodePrivate> _mThisNode;
};

GreEndNamespace
*/

#endif
 
