//////////////////////////////////////////////////////////////////////
//
//  Window.h
//  This source file is part of Gre
//		(Gang's Resource Engine)
//
//  Copyright (c) 2015 - 2016 Luk2010
//  Created on 07/11/2015.
//
//////////////////////////////////////////////////////////////////////
/*
 -----------------------------------------------------------------------------
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 -----------------------------------------------------------------------------
 */

#ifndef __GResource__Window__
#define __GResource__Window__

#include "Resource.h"
#include "RenderContext.h"
#include "LoopBehaviours.h"
#include "RenderTarget.h"

GreBeginNamespace

typedef std::pair<int, int> WindowSize;

//////////////////////////////////////////////////////////////////////
/// @brief A Window Object.
///
/// A Window is a specific RenderTarget, which should also contains
/// a RenderContext. The Window should also provides handling of the
/// Hardware Keyboard when focused, and Hardware Mouse.
///
/// The Window object is highly platform-dependent, and should be
/// different for each platforms.
///
/// In order to draw onto this Window, you should select a RenderScene
/// using RenderTarget::selectScene(), and then register this RenderTarget
/// to the RendererDrawLoop using ResourceManager::getRendererDrawLoop().registerRenderTarget().
/// Also, don't forget to associate a RenderContext using RenderTarget::setRenderContext().
/// Remember this RenderContext must be created by the Renderer.
///
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC WindowPrivate : public RenderTargetPrivate
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    WindowPrivate (const std::string& name);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~WindowPrivate() noexcept(false);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Treat Event in the Event Queue, if it has one.
    /// @return True if an Event has been treated. The return value of this
    /// function is not an Error check.
    //////////////////////////////////////////////////////////////////////
    virtual bool pollEvent();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Return True if Window is not opened.
    //////////////////////////////////////////////////////////////////////
    virtual bool isClosed() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Set a new title for this Window.
    //////////////////////////////////////////////////////////////////////
    virtual void setTitle(const std::string& title);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a description of the Surface this Window covers.
    //////////////////////////////////////////////////////////////////////
    virtual Surface getSurface() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Called after pollEvent.
    //////////////////////////////////////////////////////////////////////
    virtual void update();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Window is visible by the User.
    /// @note Window::isExposed() and Window::isClosed() can return the same
    /// value (false) if Window is minimized.
    //////////////////////////////////////////////////////////////////////
    virtual bool isExposed() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if this RenderTarget contains a RenderContext
    /// and should be drawed by the Renderer during the first phase.
    //////////////////////////////////////////////////////////////////////
    virtual bool holdsRenderContext() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Change the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual void setRenderContext(const RenderContext& renderCtxt);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual RenderContextHolder getRenderContext();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual const RenderContextHolder getRenderContext() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a loop behaviour function.
    //////////////////////////////////////////////////////////////////////
    virtual void addLoopBehaviour(LoopBehaviour behaviour);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Erases every Loop Behaviours.
    //////////////////////////////////////////////////////////////////////
    virtual void clearLoopBehaviour();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Window has been exposed, then closed.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasBeenClosed() const;
  
protected:
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Called when receiving Update Event.
    /// [thread-safe]
    //////////////////////////////////////////////////////////////////////
    virtual void onUpdateEvent(const UpdateEvent& e);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Updates 'iLastUpdate' and calls 'iLoopBehaviours'.
    //////////////////////////////////////////////////////////////////////
    virtual void iUpdateTimerAndBehaviours();
    
protected:
    
    /// @brief Window's title.
    std::string iTitle;
    
    /// @brief Surface used by the Window.
    Surface iSurface;
    
    /// @brief True if Window is exposed.
    bool iExposed;
    
    /// @brief True if Window is closed.
    bool iClosed;
    
    /// @brief Holds the RenderContext linked to this Window.
    RenderContextHolder iRenderContext;
    
    /// @brief Helper object to hold LoopBehaviour functions.
    LoopBehaviours iLoopBehaviours;
    
    /// @brief Last Update time.
    UpdateTime iLastUpdate;
};

/// @brief SpecializedResourceHolder for WindowPrivate.
typedef SpecializedResourceHolder<WindowPrivate> WindowHolder;

/// @brief SpecializedResourceHolderList for WindowPrivate.
typedef SpecializedResourceHolderList<WindowPrivate> WindowHolderList;

//////////////////////////////////////////////////////////////////////
/// @brief SpecializedResourceUser for WindowPrivate.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC Window : public RenderTarget
{
public:
    
    POOLED(Pools::Resource)

    //////////////////////////////////////////////////////////////////////
    /// @brief Constructs a Window from pointer.
    //////////////////////////////////////////////////////////////////////
    Window (const WindowPrivate* pointer);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Constructs a Window from holder.
    //////////////////////////////////////////////////////////////////////
    Window (const WindowHolder& holder);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Constructs a Window from user.
    //////////////////////////////////////////////////////////////////////
    Window (const Window& user);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Destructs the Window.
    //////////////////////////////////////////////////////////////////////
    virtual ~Window();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a new ResourceHolder in order to use the Resource.
    //////////////////////////////////////////////////////////////////////
    WindowHolder lock();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a new ResourceHolder in order to use the Resource.
    //////////////////////////////////////////////////////////////////////
    const WindowHolder lock() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Treat Event in the Event Queue, if it has one.
    /// @return True if an Event has been treated. The return value of this
    /// function is not an Error check.
    //////////////////////////////////////////////////////////////////////
    virtual bool pollEvent();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Return True if Window is not opened.
    //////////////////////////////////////////////////////////////////////
    virtual bool isClosed() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Set a new title for this Window.
    //////////////////////////////////////////////////////////////////////
    virtual void setTitle(const std::string& title);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns a description of the Surface this Window covers.
    //////////////////////////////////////////////////////////////////////
    virtual Surface getSurface() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Called after pollEvent.
    //////////////////////////////////////////////////////////////////////
    virtual void update();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Window is visible by the User.
    /// @note Window::isExposed() and Window::isClosed() can return the same
    /// value (false) if Window is minimized.
    //////////////////////////////////////////////////////////////////////
    virtual bool isExposed() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if this RenderTarget contains a RenderContext
    /// and should be drawed by the Renderer during the first phase.
    //////////////////////////////////////////////////////////////////////
    virtual bool holdsRenderContext() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Change the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual void setRenderContext(const RenderContext& renderCtxt);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual RenderContextHolder getRenderContext();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the RenderContext used by this Window.
    //////////////////////////////////////////////////////////////////////
    virtual const RenderContextHolder getRenderContext() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Adds a loop behaviour function.
    //////////////////////////////////////////////////////////////////////
    virtual void addLoopBehaviour(LoopBehaviour behaviour);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Erases every Loop Behaviours.
    //////////////////////////////////////////////////////////////////////
    virtual void clearLoopBehaviour();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Window has been exposed, then closed.
    //////////////////////////////////////////////////////////////////////
    virtual bool hasBeenClosed() const;
    
    /// @brief A Null Window object.
    static Window Null;
};

//////////////////////////////////////////////////////////////////////
/// @brief ResourceLoader for WindowPrivate.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC WindowLoader : public ResourceLoader
{
public:
    
    POOLED(Pools::Loader)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    WindowLoader();
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~WindowLoader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Creates a Window.
    //////////////////////////////////////////////////////////////////////
    virtual WindowHolder load ( const std::string& name , int x0 , int y0 , int wid , int height ) const = 0;
};

/// @brief ResourceLoaderFactory for WindowLoader.
typedef ResourceLoaderFactory<WindowLoader> WindowLoaderFactory;

class WindowManager
{
public:
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    WindowManager();
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~WindowManager();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Window from given arguments.
    //////////////////////////////////////////////////////////////////////
    virtual Window load ( const std::string& name , int x0 , int y0 , int wid , int height );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a Window into this Manager.
    /// Returns Window::Null if the Window already exists in this Manager.
    //////////////////////////////////////////////////////////////////////
    virtual Window load ( const WindowHolder& holder );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Window described by given name.
    //////////////////////////////////////////////////////////////////////
    virtual Window get ( const std::string& name );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Window described by given name.
    //////////////////////////////////////////////////////////////////////
    virtual const Window get ( const std::string& name ) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the first active Window.
    //////////////////////////////////////////////////////////////////////
    virtual Window getFirstActive();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns every Windows.
    //////////////////////////////////////////////////////////////////////
    virtual WindowHolderList& getWindows();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns every Windows.
    //////////////////////////////////////////////////////////////////////
    virtual const WindowHolderList& getWindows() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Removes Window described by given name.
    /// Also launch a WindowMustClose event to this Window.
    //////////////////////////////////////////////////////////////////////
    virtual void remove ( const std::string& name );
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Removes every Window.
    //////////////////////////////////////////////////////////////////////
    virtual void clearWindows();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iFactory' property.
    //////////////////////////////////////////////////////////////////////
    virtual WindowLoaderFactory& getWindowLoaderFactory();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the 'iFactory' property.
    //////////////////////////////////////////////////////////////////////
    virtual const WindowLoaderFactory& getWindowLoaderFactory() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears Windows and Factory.
    //////////////////////////////////////////////////////////////////////
    virtual void clear();
    
protected:
    
    /// @brief Windows loaded into this Manager.
    WindowHolderList iWindows;
    
    /// @brief WindowLoaderFactory.
    WindowLoaderFactory iFactory;
};

GreEndNamespace
#endif /* defined(__GResource__Window__) */
