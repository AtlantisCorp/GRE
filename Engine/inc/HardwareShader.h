//////////////////////////////////////////////////////////////////////
//
//  HardwareShader.h
//  This source file is part of Gre
//		(Gang's Resource Engine)
//
//  Copyright (c) 2015 - 2016 Luk2010
//  Created on 06/01/2016.
//
//////////////////////////////////////////////////////////////////////
/*
 -----------------------------------------------------------------------------
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 -----------------------------------------------------------------------------
 */

#ifndef GRE_HardwareShader_h
#define GRE_HardwareShader_h

#include "Pools.h"
#include "Resource.h"

GreBeginNamespace

//////////////////////////////////////////////////////////////////////
/// @brief Shader's possibles Types.
//////////////////////////////////////////////////////////////////////
enum class ShaderType
{
    /// @brief A Null Type. This describes an invalid Shader.
    Null,
    
    /// @brief Shader stage in the rendering pipeline that handles the
    /// processing of individual vertices.
    /// A vertex shader receives a single vertex from the vertex stream and
    /// generates a single vertex to the output vertex stream.
    Vertex,
    
    /// @brief Shader stage that will processes a Fragment generated by the
    /// Rasterization into a set of colors and a single depth value.
    Fragment
};

//////////////////////////////////////////////////////////////////////
/// @brief Represents a Shader interface.
///
/// This Shader class has the only purpose to hold a handle to the
/// specific-shader implementation. The Shader object is created, then
/// a source is linked, and the Shader is then compiled.
///
/// The Shader object is owned by HardwareProgramManager. You can load
/// a Shader using this manager.
///
/// Load a Shader
///  - HardwareProgramManager:: loadShader().
///  - HardwareShader:: setSource().
///  - HardwareShader:: compile().
///
/// setSource() and compile() can be done in HardwareProgramManager::loadShader()
/// if provided right args.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC HardwareShaderPrivate : public Resource
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    HardwareShaderPrivate(const std::string& name, const ShaderType& type);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    HardwareShaderPrivate(const std::string& name, const ShaderType& type, const std::string& text);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    virtual ~HardwareShaderPrivate();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Type of this Shader.
    //////////////////////////////////////////////////////////////////////
    virtual ShaderType getType() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets the source for this Shader.
    //////////////////////////////////////////////////////////////////////
    virtual void setSource(const std::string& source);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the source for this Shader.
    //////////////////////////////////////////////////////////////////////
    virtual const std::string& getSource() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Compile the shader and should return true on success.
    //////////////////////////////////////////////////////////////////////
    virtual bool compile() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Shader is successfully compiled.
    //////////////////////////////////////////////////////////////////////
    virtual bool isCompiled() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the HardwareShader, but do not change its type.
    //////////////////////////////////////////////////////////////////////
    virtual void clear();
    
protected:
    
    /// @brief Holds the Shader's type.
    ShaderType iType;
    
    /// @brief Holds the source text of this Shader.
    std::string iSource;
    
    /// @brief Flag 'Is the Shader compiled ?'
    mutable bool iCompiled;
};

/// @brief SpecializedResourceHolder for HardwareShaderPrivate.
typedef SpecializedResourceHolder<HardwareShaderPrivate> HardwareShaderHolder;

/// @brief SpecializedResourceHolderList for HardwareShaderPrivate.
typedef SpecializedResourceHolderList<HardwareShaderPrivate> HardwareShaderHolderList;

//////////////////////////////////////////////////////////////////////
/// @brief SpecializedResourceUser for HardwareShaderPrivate.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC HardwareShader : public SpecializedResourceUser<HardwareShaderPrivate>
{
public:
    
    POOLED(Pools::Resource)
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    HardwareShader(const HardwareShaderPrivate* pointer);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    HardwareShader(const HardwareShaderHolder& holder);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    HardwareShader(const HardwareShader& user);
    
    //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////
    ~HardwareShader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the Type of this Shader.
    //////////////////////////////////////////////////////////////////////
    ShaderType getType() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Sets the source for this Shader.
    //////////////////////////////////////////////////////////////////////
    void setSource(const std::string& source);
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns the source for this Shader.
    //////////////////////////////////////////////////////////////////////
    const std::string getSource() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Compile the shader and should return true on success.
    //////////////////////////////////////////////////////////////////////
    bool compile() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if the Shader is successfully compiled.
    //////////////////////////////////////////////////////////////////////
    bool isCompiled() const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Clears the HardwareShader, but do not change its type.
    //////////////////////////////////////////////////////////////////////
    void clear();
    
    /// @brief A Null HardwareShader object.
    static HardwareShader Null;
    
    /// @brief The HardwareShader Passthrough.
    static HardwareShader VertexPassThrough;
    static HardwareShader FragmentPassThrough;
};

//////////////////////////////////////////////////////////////////////
/// @brief A HardwareShader Loader.
//////////////////////////////////////////////////////////////////////
class DLL_PUBLIC HardwareShaderLoader : public ResourceLoader
{
public:
    
    POOLED(Pools::Loader)
    
    HardwareShaderLoader();
    virtual ~HardwareShaderLoader();
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Returns true if Resource::Type is ::HdwShader.
    //////////////////////////////////////////////////////////////////////
    virtual bool isTypeSupported(Resource::Type type) const;
    
    //////////////////////////////////////////////////////////////////////
    /// @brief Loads a HardwareShader.
    /// Default implementation returns a null pointer.
    //////////////////////////////////////////////////////////////////////
    virtual Resource* load(Resource::Type type, const std::string& name, const std::string& filepath, const ShaderType& stype) const;
};

typedef ResourceLoaderFactory<HardwareShaderLoader> HardwareShaderLoaderFactory;

GreEndNamespace

#endif
